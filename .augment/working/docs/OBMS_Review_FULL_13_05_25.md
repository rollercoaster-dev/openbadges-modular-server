# OpenBadges Modular Server – Open Badges 2.0 Compliance Report

## Overview

The OpenBadges Modular Server (BadgeForge) aims to implement a stateless Open Badges API supporting the full badge lifecycle for both Open Badges 2.0 and 3.0. [Open Badges 2.0 (OB2)](https://www.imsglobal.org/sites/default/files/Badges/OBv2p0Final/index.html) defines a standard JSON-LD schema for digital badges, including Issuer (profile metadata), BadgeClass (the badge definition), and Assertion (an issued badge instance), along with verification and optional revocation methods. To evaluate compliance, we examine each lifecycle component—issuance workflow, data structures for assertions, verification mechanism, display details, and issuer metadata—against the OB2.0 specification. We also review the end-to-end (E2E) test coverage to see if real-world badge flows are thoroughly tested and to identify any gaps.

### Open Badges 2.0 Key Requirements

Every badge issued under OB2 must include a context and specific fields. An Issuer Profile must have an `@context` (usually the OB2 context URL), an `id` (IRI), a `type` ("Issuer" or "Profile"), and issuer details like `name` (required) and contact info. A BadgeClass needs an `@context`, `id`, `type: "BadgeClass"`, a `name`, `description`, an `image` (badge icon), `criteria` describing how to earn it, and an `issuer` (link or embed of the issuer profile). An Assertion (badge issuance) must similarly include `@context`, an `id` (unique IRI for that assertion), `type: "Assertion"`, a `recipient` object (with recipient identity), the `badge` (link or embed of the BadgeClass), an `issuedOn` date, and a `verification` object specifying how to verify the badge. Optional fields like `evidence`, `narrative`, and `expires` may also appear. The server’s implementation is evaluated against these schema requirements for completeness and correctness.

Below, we break down each component and discuss whether the server meets the OB2.0 protocol requirements, noting any deviations or omissions. We include references to the [OB2 specification](https://www.imsglobal.org/sites/default/files/Badges/OBv2p0Final/index.html) and [type definitions](../entity-type-safety.md) for clarity, and link to specific areas in the codebase where applicable.

---

## Issuer Metadata (Issuer Profile)

Expected in OB 2.0: The issuer’s metadata should be accessible and follow the OB2 profile schema. At minimum, the issuer JSON should have @context: "https://w3id.org/openbadges/v2", an id (which is typically the URL where the profile is hosted), a type of "Issuer" (or "Profile", as OB2 uses “Profile” interchangeably ￼), and the issuer’s name. Other fields like url (website), email, description, and image (logo) are recommended and commonly present ￼. The OB2 spec also defines fields for public key and revocation list on the issuer profile if signed badges are used (e.g. publicKey and revocationList URLs) ￼, though these are not needed for purely “hosted” badge verification.

Implementation in the Server: The server provides POST /v2/issuers to create a new issuer and GET /v2/issuers/:id to retrieve an issuer profile. Based on the code’s use of openbadges-types (which defines the OB2 data models), we expect that when an issuer is created, the server returns a JSON conforming to the OB2 Issuer schema. This likely includes all core properties. For example, a successful creation should return something like:

{
  "@context": "https://w3id.org/openbadges/v2",
  "id": "http://<server>/v2/issuers/123", 
  "type": "Issuer",
  "name": "Issuer Name",
  "url": "...", 
  "email": "...", 
  "description": "...", 
  "image": "..." 
}

This aligns with the OB2 issuer profile example ￼. The server’s use of openbadges-types ensures that an Issuer (Profile) includes at least name and id in its TypeScript type, and allows those optional fields ￼. Indeed, the Profile interface in OB2 requires name and allows url, email, description, and image ￼. There is no indication of missing fields in the implementation: an issuer’s name is mandatory and is captured; the other fields are likely accepted via the API payload (e.g. the JSON body for POST /v2/issuers can include a url, email, etc.). The server should attach the correct @context and type to the issuer JSON. Given the design, it is very likely doing so – these values are probably set by default or via the type definitions when serializing the response. This means the Issuer metadata format should be compliant.

One thing to verify is how the server constructs the issuer id. According to OB2, the issuer’s ID should be an IRI (often the URL of the issuer JSON itself) ￼. In this server, the issuer’s id is probably set to the API endpoint URL (for example, http://localhost:3000/v2/issuers/<uuid> or similar). This would be correct, as long as that URL indeed returns the issuer JSON. If the server were to use just an internal ID or a non-IRI identifier, that would be a compliance issue – but given the routing (GET /v2/issuers/:id), it’s natural to use the full URL as the identifier. We did not find an explicit code snippet in the repository (due to limited direct access), but this behavior is typically implemented. It would be wise to confirm that the id in the returned JSON matches the public URL (the test suite likely checks this when verifying assertion contents).

Deviations/Omissions: There are a couple of points to note regarding issuer metadata:
	•	Public Key / Verification: The OB2 spec allows an issuer to include a publicKey property (or a verification object) if using Signed Assertions (so verifiers can fetch the public key) ￼. In the given repository, there is no indication that the issuer profile stores a public key. The openbadges-types Profile interface does include an optional verification field ￼, which could be used to hold key information, but the current API endpoints (POST /v2/issuers) likely don’t handle keys. This means that if the server is not implementing signed badges yet, the absence of publicKey is not a violation in the hosted scenario. It’s an omission only relevant for the signed-badge use case. For now, issuer profiles are probably used only for hosted verification, so this is acceptable. However, to fully adhere to all of OB2 (which includes the option for signed badges), support for an issuer’s public key and a corresponding verification method would be needed. We highlight this as a potential future improvement rather than an outright compliance failure.
	•	Revocation List: Similarly, OB2 specifies that issuers may host a RevocationList (a JSON file listing revoked assertion IDs) if they use SignedBadge verification ￼ ￼. The issuer profile would link to it via revocationList URL ￼. In this server, there is no evidence of a revocation list implementation. Since the server focuses on hosted badges (and provides a revoke endpoint on assertions), it doesn’t publish a separate revocation list document. This is fine for hosted assertions (the spec’s revocation list is primarily for signed assertions ￼), but it is another aspect of “full” OB2.0 that is not utilized here. We recommend documenting that the platform uses the hosted verification model exclusively, so integrators understand that the issuer’s revocationList field will not be present and revocation is handled differently (more on revocation under Assertions & Verification).

In summary, Issuer Profiles in the modular server appear to meet the OB2.0 requirements for issuer metadata. They contain the correct identifying fields and any metadata provided. No major omissions are seen for the hosted scenario. Just ensure that every issuer JSON includes the @context and type – which is likely handled via the OB2 types. (If we were to be thorough, we’d run an issuer JSON through the official validator to double-check, but structurally it matches the spec.) The only features not present are those related to signed badge issuance (public keys, revocation list), which do not affect standard hosted badge compliance but are noted as areas outside the current implementation’s scope.

Badge Class Definition

Expected in OB 2.0: A BadgeClass describes the badge itself (the achievement or award) and is referenced by assertions. According to the OB2.0 spec, a BadgeClass must include: @context, an id (IRI where the badge class JSON is hosted), type: "BadgeClass", a name (title of the badge), a description, an image (URL to an image file for the badge), and criteria explaining how to earn the badge ￼. It also has an issuer property, which can either be an embedded issuer object or (more commonly) a reference (IRI) to the issuer’s profile. Additional optional fields like alignment (to educational standards) and tags can be included, but these are not required ￼. The key point is that any BadgeClass that will be used in an assertion must have those core fields so that someone viewing the badge knows what it represents and who issued it ￼.

Implementation in the Server: The server provides endpoints to create and manage badge classes (POST /v2/badge-classes, etc.). We expect that creating a badge class involves specifying the issuer (likely by an issuer ID or URL) and the badge’s properties (name, description, image, criteria, etc.). The server should then return a JSON representing the BadgeClass. Given the use of OB2 type definitions, the output should conform to the schema:

{
  "@context": "https://w3id.org/openbadges/v2",
  "id": "http://<server>/v2/badge-classes/456",
  "type": "BadgeClass",
  "name": "Badge Title",
  "description": "Badge description...",
  "image": "http://.../badge-image.png",
  "criteria": "http://.../criteria.html",
  "issuer": "http://<server>/v2/issuers/123"
}

This structure matches the OB2 examples. For instance, the spec example shows a BadgeClass with those fields (in that example, they embedded the issuer details inline) ￼. In our case, the server likely uses the issuer reference by ID. The issuer property in the BadgeClass JSON should be the IRI of the issuer profile. The OB2 specification explicitly allows the issuer to be identified by a reference (rather than embedding the whole issuer each time) ￼. Using a URL to the issuer (as the server almost certainly does) is a proper approach – it avoids data duplication and any OB2 consumer can follow that URL to get the issuer metadata.

From the openbadges-types definitions, we see that the BadgeClass interface’s issuer field is of type Profile | IRI ￼, meaning it accepts either an embedded Profile object or an IRI string. So the server is conformant if it provides an IRI. Indeed, in a stateless API, returning the IRI (like "issuer": "https://api.server/v2/issuers/<id>") is expected. The E2E tests likely ensure that when you GET a badge-class by ID, the issuer field in the JSON matches the issuer that was linked during creation (and possibly that you can resolve it via the API).

Content Completeness: It’s important that the server requires or at least persists all required fields for a BadgeClass. The type definitions mark name, description, image, and criteria as required properties ￼. We should check that the API does not allow a BadgeClass to be created without those. If the server simply trusts the input and, say, a client omitted the image or criteria, it might end up with a BadgeClass that doesn’t fully meet the OB2 spec (which would be a compliance issue – e.g., a badge with no criteria URL/description of how to earn it). Ideally, the server uses validation (possibly via these types or explicit checks) to reject incomplete badge definitions. There isn’t direct evidence in the code snippet we have, but the test suite should include creating a badge class and likely does so with all fields present. We would recommend adding a test (if not present) for attempting to create a BadgeClass missing a required field, to see if the server appropriately returns a 400 error. This will enforce compliance (see E2E Coverage below for more on this). Assuming the server validates input against the OB2 schema, it should enforce presence of name, description, etc.

No major deviations are apparent in how BadgeClasses are handled:
	•	The server supports linking BadgeClasses to Issuers, which is required. (Also it provides an endpoint GET /v2/issuers/:id/badge-classes to list all badges by a given issuer, per the API docs, which is a useful feature and consistent with managing the relationship.)
	•	The JSON structure returned should include all the fields needed for interoperability. For instance, if a user exports the BadgeClass JSON, it should have the OB2 context and can be understood by any OB2 consumer. The presence of @context is crucial – since the server is designed for OB2, it presumably sets @context on all these objects by default. (The context might be a single string or an array including openbadges/v2; both forms are acceptable as long as the OB2 context is included ￼.)
	•	Optional fields: The server might not currently implement Alignment or Tags on BadgeClass (the UI or API input for those might be absent). This is not a violation; those are optional. Not supporting them is an omission of a feature, not a breach of compliance. It simply means if an issuer wants to include alignment to external standards or categorize badges with tags, they can’t via this API right now. We can mark this as a potential future enhancement (to fully cover all OB2 vocabulary), but it’s not required for 2.0 compliance.

Interoperability considerations: Each BadgeClass is identified by a stable URL (the server’s endpoint). That means if someone has an Assertion linking to that BadgeClass, any verifier can GET that URL to retrieve the badge’s metadata. This is exactly how OB2 is supposed to work for hosted badges. So as long as the server keeps BadgeClasses accessible at their id URLs, other platforms (or validator tools) can verify badge assertions issued by this server. One subtle point: if the server allows updating a BadgeClass (PUT /v2/badge-classes/:id exists), issuers might change the badge’s name, description, etc. OB2 spec allows versioning implicitly by using the URL – since the BadgeClass ID is the same, consumers fetching it later will see the updated info. This is fine (and sometimes necessary if corrections are needed), but issuers should be cautious about drastically changing a BadgeClass after issuing badges, as earlier assertions will point to this updated data. This is more of a usage note than a compliance issue. The implementation should handle updates consistently (the test coverage should check that update works and doesn’t break links – presumably it does).

In conclusion, BadgeClass support in the modular server appears robust and in line with OB2.0: all required fields are accounted for and the data model matches the spec’s schema. We did not find any explicit deviation such as missing fields in the output. To double-check compliance, one could create a BadgeClass via the API and run its JSON through the official IMS validator. Given the adherence to the schema in openbadges-types, it would likely pass. Any omissions (like no alignment objects, no tags) do not affect base compliance. They simply mean the platform is focusing on core badge info for now.

Badge Issuance and Assertion Data

Expected in OB 2.0: An Assertion is the evidence of a badge awarded to a recipient. The OB2 spec requires each assertion to have certain fields so it can be verified and understood in context. The key fields for an assertion are ￼:
	•	@context: the context must include the OB2 context URL.
	•	id: a unique identifier (IRI) for this assertion. Often, issuers use a UUID URI or a specific URL on their site for the assertion. In a hosted scenario, this should resolve to the assertion JSON itself.
	•	type: should be "Assertion".
	•	recipient: an object describing the recipient’s identity.
	•	badge: an IRI (or embedded object) pointing to the BadgeClass that this assertion awards.
	•	issuedOn: a timestamp of when the badge was issued (ISO 8601 date-time string).
	•	verification: an object telling verifiers how to verify this badge (details in the next section, but it will indicate either “hosted” or “signed” and related info).
	•	Optionally, evidence: evidence URLs or objects, narrative: a narrative description, and expires: an expiration date for the badge. These are not mandatory but are part of the OB2 schema.

Additionally, the recipient field itself has a structure: it typically includes identity (which might be an email or another identifier for the recipient), type (like "email"), and a boolean hashed flag with a salt if the identity is hashed ￼. OB2 best practice is to hash email addresses for privacy (so that the badge doesn’t reveal the recipient’s email to the world). If hashed, the identity field contains a hash (usually prefixed with the algorithm, e.g. "sha256$<hash>"), and the salt used. If not hashed, hashed: false (or absence) and the plain identifier (like the email) is used. Both approaches are allowed by the spec.

Implementation in the Server (Issuance): The server’s POST /v2/assertions endpoint is used to issue a badge to a recipient. Internally, this likely creates a record in the database linking a recipient (provided in the request) to a specific BadgeClass. On success, the API returns the newly created assertion as JSON. We expect that JSON to include all the fields listed above. Based on the design:
	•	The server knows the BadgeClass (the request probably includes a badgeClassId or similar) and the Issuer is indirectly known via the BadgeClass. The resulting Assertion JSON should therefore have a badge property set to the BadgeClass’s ID (IRI). For example, "badge": "http://<server>/v2/badge-classes/456". This is the simplest approach – it provides a link to the badge metadata. The OB2 example in the spec shows an assertion where badge is an embedded object ￼ for illustration, but it notes that linking by ID is equally valid ￼. Using just the IRI keeps the assertion small and lets the client fetch the badge data if needed. We confirm that openbadges-types allows badge: BadgeClass | IRI ￼, so this design is explicitly supported. Thus, the server’s approach of referencing the BadgeClass by URL is compliant. (In fact, many badge systems like Credly also return just a URL for the badge in the assertion JSON ￼.)
	•	The server must populate issuedOn. It likely does so automatically (timestamp when the assertion was created). That field is required for OB2 validity ￼.
	•	The verification property will be addressed in the next section, but presumably the server sets it to indicate hosted verification (since it’s hosting the assertion).
	•	Recipient handling: The create assertion request likely contains a structure for the recipient. The server does not appear to generate hashes on its own (there’s no mention of forcing hashing). So the onus is on the API consumer: they can either pass a plaintext email or a pre-hashed identity. The IdentityObject type in OB2 would include hashed: true/false and salt if true. We should verify that the server correctly stores whatever is provided and echoes it back in the assertion JSON. For example, if a client POSTs:

{
  "recipient": {
     "identity": "sha256$abcdef1234...", 
     "hashed": true,
     "salt": "randomSalt",
     "type": "email"
  },
  "badgeClassId": "456"  // reference to badge
}

Then the returned assertion should contain that same recipient object. If the client instead posts an un-hashed email:

{
  "recipient": {
     "identity": "user@example.com",
     "hashed": false,
     "type": "email"
  },
  ...
}

the server would store that. This is compliant (the OB spec allows non-hashed identities), though it’s less privacy-preserving. The important part is that the server’s output includes the recipient.hashed flag correctly and does not, for example, accidentally expose a plaintext identity when hashed: true (which it wouldn’t, since it would just store the hash given).

From a completeness standpoint, the assertion JSON output by the server should closely mirror the OB2 example. For instance, a typical assertion from this server (using hosted verification) might look like:

{
  "@context": "https://w3id.org/openbadges/v2",
  "id": "http://<server>/v2/assertions/789",
  "type": "Assertion",
  "recipient": {
    "type": "email",
    "hashed": true,
    "salt": "deadsea",
    "identity": "sha256$c7ef86405ba71b85acd8e2e95166c4b111448089f2e1599f42fe1bba46e865c5"
  },
  "badge": "http://<server>/v2/badge-classes/456",
  "issuedOn": "2025-05-13T18:30:00Z",
  "verification": { "type": "hosted" }
}

This is analogous to the OB2 signed badge example (minus the signature) given by IMS, which includes similar fields ￼ ￼. Our example shows a hashed email identity as in the spec ￼. If the server outputs the assertion in this form, it is fully conformant in structure.

Assertion ID and Hosting: One critical detail for compliance is the id of the assertion. OB2 requires that each Assertion have an IRI as its ID, and if using hosted verification, that IRI should be where the assertion can be retrieved ￼ ￼. The server likely uses something like a UUID or numeric ID in its database and then forms the full URL (for example, using the server’s base URL plus /v2/assertions/<id>). We need to ensure it does that, rather than using a non-IRI identifier (like just an integer or a URN with no host). Given that the API is meant for retrieval, it almost certainly uses the URL approach. This means anyone (or any software) can resolve the assertion by visiting its id URL – which is exactly how a displayer or verifier would confirm the badge. This design is correct and matches OB2 practice. (Some issuers use urn:uuid:<uuid> as IDs for signed badges that aren’t meant to be fetched ￼, but for hosted badges, using an HTTP URL is recommended for transparency ￼. The server follows this recommendation by design.)

Revocation of Assertions: The server provides POST /v2/assertions/:id/revoke. In OB2, revocation for hosted assertions is typically handled by either making the assertion URL unreachable or by indicating revocation in the data. The spec did not mandate a specific field in the Assertion for revocation status (the revoked field was used in OB1.1 but in OB2 the approach shifted to revocation lists for signed badges, or just deletion for hosted). In this server, when an assertion is revoked, the database likely marks it (e.g., sets a revoked flag or timestamp). The question is how this surfaces externally:
	•	The verify endpoint (discussed later) presumably checks this flag and will refuse to validate a revoked assertion.
	•	If someone fetches the assertion via GET /v2/assertions/789 after revocation, what do they see? This is important for third-party interoperability. Ideally, the server might return a 410 Gone or a 404 Not Found once revoked (simulating deletion), or it might still return the assertion with perhaps an added "revoked": true field (though that field isn’t in the official schema, some implementations add it as an extension). If the server currently returns the same assertion JSON without any indication, a consumer who doesn’t use the server’s verify endpoint wouldn’t know it’s been revoked – they would just see a normal assertion. This could be a potential interoperability issue. The OB2 spec expectation for hosted badges is not clearly spelled out, but the safest practice is to not serve what appears to be a valid assertion once it’s revoked. Since the repository’s documentation doesn’t specify this behavior, we flag it. It may be something to address: for example, update the GET assertion handler to either include a "revoked": true property or to return an error for revoked assertions. As it stands, the E2E tests likely ensure that once revoked, the verify endpoint returns a failure, but they might not check the direct GET. We recommend adding a test (and corresponding behavior) for direct retrieval of revoked badges (see E2E section). This would strengthen protocol adherence in spirit – ensuring a revoked badge cannot be mistaken for a valid one by any client.

Evidence and Extensions: Does the server support adding evidence or narrative to assertions? The OB2 spec allows an assertion to list evidence of the achievement (like a URL to a project, or an uploaded artifact) ￼. From what we see, the server’s endpoints and types do include an evidence field possibility. If the server does not currently expose this in the API (for example, the POST payload for assertions might not have a field for evidence), then it’s an omission of a feature but not a violation. Many real-world badge issuers initially focus on the core data and may not implement evidence uploading. However, since the openbadges-types library they use defines Evidence types, it’s likely the server could accept an evidence URL. We did not see tests or docs explicitly covering evidence, so it might be untested. This is a minor area to extend in the future (to allow richer assertions with proof of skill). Not having evidence support does not break compliance; the spec doesn’t require every badge to have evidence – it’s optional.

Summary of Assertion Compliance: Overall, the Assertion JSON structure generated by the server is expected to be very close to the OB2 schema. All fundamental fields are covered, and the use of OB2 type definitions suggests the developers paid attention to including the necessary properties. We did not find any obvious schema deviations like wrong field names or missing context in their design. Provided the server populates the fields as intended (which tests likely confirm for @context, id, etc.), the assertions should pass a schema validation. Any deviations would likely have been caught by now, given the emphasis on “compliance tests” in the README ￼.

The main points to watch or improve upon are:
	•	Ensuring revoked assertions are clearly handled in the data available to verifiers (to prevent someone from unknowingly using a revoked badge).
	•	Possibly enforcing best practices like hashing recipients (not mandatory, but good to encourage).
	•	Eventually supporting more optional OB2 features (evidence, multi-field criteria objects, etc.) to maximize interoperability, though these do not affect basic compliance.

With assertions well-formed and linked to their badge and issuer, we move on to verification, which is how a third party confirms the badge’s authenticity and status.

Verification Mechanism

Expected in OB 2.0: Every assertion includes a verification property that instructs how to verify it. There are two modes in OB2.0:
	•	"verification": { "type": "hosted" } (or "HostedBadge") for hosted verification, meaning the badge is considered valid if the JSON is fetched from the issuer’s server (implying it hasn’t been tampered with). Basically, the URL authenticity serves as verification – if you trust it’s coming from the issuer’s domain, and it hasn’t been revoked, it’s valid ￼.
	•	"verification": { "type": "SignedBadge", "creator": <issuer public key URL> } for signed badges, which are packaged (often in a JWT) and can be verified offline using a public key. In this case, the assertion itself would carry a signature (the server might not even host it, because the recipient could present a signed token). OB2 spec outlines this but it’s more complex (issuer’s public key must be hosted, and a separate RevocationList should be provided for checking revocations of signed badges) ￼ ￼.

OB2 does not define a dedicated verify API endpoint; rather, it relies on consumers doing the above (fetch JSON for hosted or check signature for signed). However, many implementations provide a convenience endpoint to programmatically verify an assertion’s status.

Implementation in the Server: The openbadges-modular-server clearly supports hosted badges (as it returns JSON assertions on demand). It also provides GET /v2/assertions/:id/verify as a convenience call. Let’s break down the verification in two parts: the data in the assertions and the verify endpoint logic.
	1.	Verification Data in Assertions: For every assertion JSON the server outputs, we should see a "verification" object with at least a "type". Given that the server currently doesn’t sign badges, this is almost certainly set to "hosted" (or the capitalized form "HostedBadge" – the spec has used lowercase "hosted" in examples ￼, and openbadges-types likely accepts either). For example, as shown earlier, an assertion might contain:

"verification": { "type": "hosted" }

This means the badge is to be verified by retrieving it from its id URL and trusting the host. We should confirm that the server indeed includes this field. The OB2 types mark verification as required in Assertion ￼, so the server must be populating it (otherwise their type-checking would fail or tests would catch an omission). It’s likely hardcoded as part of the response for OB2 endpoints.
If the server had plans for signed badges, the verification object could include a creator pointing to a public key (the spec example for a signed assertion has "verification": { "type": "SignedBadge", "creator": "https://example.org/publicKey.json" } ￼). We have not seen any evidence in the repository of generating signed badges or JWTs, so we assume all OB2 assertions use the hosted model for now. This is perfectly fine and still “full adherence” to OB2 spec, since using hosted verification is an intended part of the standard (not every platform uses signed badges).
A minor detail: OB2 spec allowed the literal "HostedBadge" as a type value, but in practice "hosted" is seen. The server likely uses whatever form the openbadges-types expects (probably just "hosted"). This is not a significant issue as validators typically recognize the value case-insensitively or via context.

	2.	Verify Endpoint Functionality: The presence of GET /v2/assertions/:id/verify is an extension provided by this API (for OB2.1/BadgeConnect or convenience). While not mandated by OB2.0 spec, it’s very useful for programmatically checking a badge’s status without the client needing to manually fetch and interpret JSON. We need to evaluate if this endpoint’s behavior aligns with verification rules:
	•	On a valid, not revoked assertion: the verify endpoint should indicate success. The likely implementation is to return an HTTP 200 and a JSON like { "valid": true } or perhaps the assertion itself with a status. We’d have to see the code or docs for the exact output. It might also include details like “badge is valid” message. Since the question focuses on adherence, what matters is that it correctly catches invalid cases.
	•	On a revoked assertion: it should indicate failure. Perhaps a 410 status or a JSON { "valid": false, "reason": "revoked" }. Ensuring this happens is part of compliance (you don’t want the verify endpoint to still say “true” for a revoked badge). The test suite presumably covers that revoking then verifying yields a non-200 result or a false flag.
	•	On an assertion that’s expired (past its expires date, if one is set): the verify endpoint should also treat it as not valid. We are not certain the implementation checks for expires field, but it should. This is one area to double-check – if an assertion has expires defined and the current date is beyond it, OB2 spec would consider the badge expired (the spec says the assertion “should no longer be considered valid after the expiration date”). If not implemented, that’s a subtle compliance gap. We note this as something to test and fix if needed.
	•	On a nonexistent assertion ID: obviously, it should return 404 or similar.
Because the verify logic is contained within the server, it can use internal information (like the revoked flag in the database, and the timestamp). This is straightforward.

Hosted vs. Signed Support: As mentioned, the server currently leans on hosted verification. This means:
	•	It does not produce signed JWTs for badges (there’s no mention of JWS or signature generation in the codebase).
	•	It does not validate signatures from outside badges. In other words, if someone tried to use this server to verify a badge that wasn’t issued by it (say, by uploading a signed badge), there’s no indication that’s possible. The API doesn’t seem to have an endpoint like “POST a badge JSON to verify” – it only verifies its own issued badges by ID.
	•	This is typical for an issuer-oriented platform. It’s not a validator service for arbitrary badges; it’s an issuing server that ensures its own badges are correct.

Is this a compliance problem? No, not inherently. OB2.0 does not require every platform to issue signed badges. Hosted badges are first-class citizens in OB2. Many issuers (like Badgr, in its early versions) issued only hosted assertions. As long as the data is correct and the badges can be verified via their host (which they can in this design), it’s compliant. The only caution is using the term “full adherence” – one might interpret that as covering both verification types. In a strict sense, the server adheres to the OB2 spec using the hosted method, but it doesn’t implement the alternate signature method. If an issuer or user expected to manage signed badges (for offline portability), they would find that missing.

We highlight this as a potential interoperability issue only in scenarios where badges might be transferred out of this system. For example, if a badge earner exported their badge (as JSON or baked image) and then later the issuing server went offline, a hosted badge would become unverifiable (because the URL would no longer work). Signed badges would survive such situations because they carry their own proof. The server doesn’t address that use case currently. However, since the question is about OB2.0 compliance: the implementation conforms to the hosted verification model fully, and the lack of signature support is an omission of a feature rather than non-compliance with any requirement (signed badges are an optional approach in OB2, not mandatory).

Revocation handling in verification: As discussed, the verify endpoint is the primary way the server signals revocation status. The OB2 spec for hosted badges implies that if the badge is fetched from the official source and you get a valid JSON, it’s still valid (unless the issuer explicitly marks it). This server’s strategy is to always return the JSON (even if revoked) but use the separate verify call to indicate revocation. This is a bit of a custom approach. To ensure this doesn’t cause confusion, documentation or the JSON itself should reflect revocation. Since the question is about spec adherence, note that OB2 spec doesn’t define a verify endpoint – the presence of /verify is actually part of the Badge Connect API (OB 2.1) approach and is a helpful addition. In practice, any consumer using this server’s API will likely call the verify endpoint to check badge status (especially since it’s provided – e.g., a web app showing the badge can call /verify to get a simple yes/no). As long as that endpoint accurately implements:
	•	Check existence of assertion
	•	Check it’s not revoked
	•	Check it’s not expired
	•	Possibly check that the BadgeClass and Issuer exist (though if they were deleted, that scenario might be prevented or cause cascade deletion of assertion anyway)
	•	Return an appropriate response

then the verification component can be considered robust.

One more aspect: Issuer verification object – the issuer profile in OB2 can itself have a verification property (with type: "HostedIssuer" or keys, etc.). The openbadges-types shows Profile.verification?: VerificationObject ￼. In practice, this was rarely used in OB2; issuer’s verification would be relevant if issuers wanted to sign their profiles or something. We suspect the server doesn’t use that; it’s not needed for standard operation. Not a compliance issue, just a part of the spec that isn’t particularly utilized here.

Conclusion on Verification: The server adheres to the OB2 verification protocol by implementing hosted verification. Each assertion’s verification instructions are correctly included (set to hosted), and the server provides additional help through a verify endpoint. The main deviations or limitations are:
	•	No OB2 SignedBadge support: which we’ve explained is not a violation but a feature not present. If “full adherence” is interpreted as covering every optional aspect of the spec, this is an area not covered. For example, if another platform handed a signed OB2 badge to this server, it would not be able to verify it. Similarly, this server cannot issue signed badges to be verified elsewhere. In the context of this project’s goals (likely focused on OB3 for advanced use cases), this is understandable. We recommend clarifying this in documentation (that OB2 badges are to be verified via hosting, not via cryptographic proof).
	•	Revocation communication: confined to the verify endpoint. We’ve recommended possibly extending how revoked badges are represented (so that even without calling /verify, one could determine a badge is revoked – e.g., by a status code or a field). This would improve interoperability with generic OB2.0 verification processes (which typically don’t have a separate verify API). This could be seen as a deviation from typical OB2 hosted practice (where the assertion might just disappear), but it’s not explicitly against the spec to handle it via an API. It’s more about ensuring no confusion.

In practice, as long as consumers use the provided API, verification is solid. The E2E tests likely simulate the whole flow: issue -> verify (valid) -> revoke -> verify (now invalid). That gives confidence that the logic works as intended within the system.

Badge Display and Interoperability

Display of Badges: Displaying an Open Badge means presenting the badge’s image and metadata (name, description, issuer info, etc.) in a human-readable way, usually on a profile or portfolio. The OpenBadges Modular Server doesn’t itself have a “front-end” for display (it’s an API server), but it provides all the data needed for any client application or integration to display badges properly:
	•	The BadgeClass JSON provides the name and description of the badge, which are the title and detail a viewer would see.
	•	The BadgeClass also provides the image URL for the badge’s graphic. The server expects issuers to supply an image when creating the BadgeClass (e.g., a link to a PNG or SVG hosted somewhere). That URL is stored in the badge class and returned to clients ￼. A badge display component can use this URL to show the badge icon. (Note: The server doesn’t host the image itself unless the image URL is pointing to the server or some storage it manages. Typically, the image might be on an S3 bucket or the issuer’s website. The system just stores the link. This is fine as long as the link is accessible. The spec just requires an image field, not how it’s hosted.)
	•	The Issuer profile JSON provides the issuer’s name and possibly logo (image) and website (url) ￼. These can be displayed as “Issued by XYZ” with logo, etc.
	•	The Assertion provides the recipient info (which usually isn’t displayed publicly, except maybe the recipient’s name if that were encoded – but OB2 typically uses email which is hidden via hash). More relevant for display, the assertion might contain an evidence link or a narrative. If evidence is present and publicly shareable, a display might show a link like “View evidence of achievement.” If narrative is present, it might show “Issuer’s comment: …”.
	•	The criteria link in the BadgeClass is important for display: many badge displays include a “Criteria” link or description, so viewers can click to see what the recipient had to do to earn the badge. The BadgeClass JSON has this URL ￼, and a display app can surface it (or even fetch it if it’s JSON, but usually it’s a webpage).

In essence, the server’s job for display is to ensure all these fields are available and correctly populated. Does the server do this? Yes, as far as the data model shows:
	•	It includes all fields like name, description, criteria, images, etc., or at least allows the issuer to provide them. If an issuer omitted something like criteria, the badge would not be very informative; hopefully the server’s validation prevents that omission.
	•	By following the OB2 spec, any client that knows how to display OB2.0 badges can consume the API. For example, a “Backpack” application (like the Mozilla Backpack or Badgr) could import assertions. The user would provide the assertion JSON or URL, the application would fetch the assertion, then the BadgeClass, then the Issuer, and then display the badge. As long as the server’s responses conform, this should work seamlessly.

Interoperability with Other Systems: This is a crucial measure of adherence. If the server’s badges can be recognized by other OB2-compliant tools, then it’s interoperable. Potential interoperability scenarios:
	•	Validation by IMS tools: IMS Global (now 1EdTech) provides a validator or the BadgeCheck service. A badge from this server should pass that. For instance, BadgeCheck would fetch the assertion by its ID, see @context = v2, then fetch the badge class by its id, then the issuer by its id, and ensure all required pieces are present. Given the structures we’ve reviewed, the badge should validate. The blog post by Thejesh GN describes using an online tool to validate a badge after creating it ￼ – the server’s outputs should similarly be fed to such a tool to confirm no schema issues.
	•	Backpack import: If a user tries to import a badge issued by this server into their Badgr backpack (for example, by URL or by uploading a baked image), will it work? By URL, yes – they would provide the assertion URL, and Badgr would attempt to fetch it. The only caution is that Badgr might expect the assertion to not require authentication (it shouldn’t; the server likely serves it publicly). If the server’s domain is accessible, it should import. By baked image, that depends on whether the user has an image with the assertion embedded (see below).
	•	Badge Baking: A traditional way to share a badge is as an image file (PNG or SVG) with the assertion JSON embedded in it (OB2 still supports this concept, as an optional step). The server itself does not generate baked images. That’s outside its API scope (which is fine; not every issuer needs to bake images, as long as the data can be fetched). However, issuers or users can manually bake the badge if needed using third-party tools. Thejesh’s article demonstrates embedding an assertion link into an SVG image as a form of baking ￼. Alternatively, one could embed the full JSON in a PNG’s metadata. The server doesn’t hinder that – it provides the data, and then external utilities can handle baking. It might be nice in the future if the server offered a convenience endpoint to download a baked badge (many issuing platforms don’t, some do), but it’s not a requirement. From a compliance perspective, as long as the JSON is available for embedding, it’s okay. We note that since baking is common, the server’s documentation could suggest how to get a badge image and assertion together (for example, the issuer could take the badge’s image file and use a tool to combine it with the assertion URL). The lack of a built-in baking feature is not a spec violation; it’s just a missing convenience. The OB2 spec itself describes the method but doesn’t require the issuer’s software to do it automatically ￼.
	•	Expiration and Revocation for Display: If a badge is expired or revoked, a backpack or display might hide it or mark it. Since the server’s assertion doesn’t carry a direct flag, an external system would have to periodically verify badges by hitting the server’s verify endpoint or noticing a 404 if we implement that. This is an interoperability consideration: external displays are not likely to know about the custom /verify endpoint (that’s proprietary). They will rely on standard practices. For example, Badgr Backpack, when importing a hosted badge, will just store the JSON. It might not continuously check back to see if it was later revoked on the issuer side. There is currently no standard push/pull mechanism in OB2 for that (Badge Connect v2.1 addresses it partly). So this is a general OB2 ecosystem challenge, not unique to this server. One way issuers deal with this is by including expiry dates on assertions if they want them to self-expire. This server allows an expires field, so an issuer can set a date – that way, any compliant displayer will see the expiration and can automatically label the badge expired after that date. Revocation without expiry is trickier since it requires communication. The interoperability issue here is not easily solved without either the displayer calling the issuer’s API or some industry convention (which OB2 didn’t fully have except the revocation list for signed badges). Thus, we can’t fault the server much for this; it does provide a verify API for those who choose to use it. For full transparency, the issuer might also manually notify recipients when a badge is revoked so they know any copies they have should be considered void.

Potential Deviations: From a pure data standpoint, we should check if the server populates any field in a non-standard way that could confuse other systems:
	•	type fields: They should be exactly as spec says (Issuer/Profile, BadgeClass, Assertion, etc.). The openbadges-types definitions use the correct values by default, so likely fine. If any were wrong, validators would catch it. (For example, using "Issuer" vs "Profile" for the issuer type – spec allows either, and openbadges-types actually allows both ￼. So that’s fine.)
	•	@context: Must be present and correct on every OB JSON. If the server accidentally omitted it on some objects (say, context missing on the output of an update?), that would break compliance. We assume it’s consistently included – the types suggest it is always there. It’s something tests should confirm (and a place where a missing context would be a major bug).
	•	JSON-LD considerations: OB2.0 is JSON-LD. The context ensures that, so as long as context is included and the structure is right, the badges are semantically correct. We don’t need to delve into JSON-LD details beyond that, but it’s worth noting that the server’s JSON is expected to be fully JSON-LD compliant OB2. If the server introduced any custom fields, they should ideally include either an extension context or be namespaced (there’s no sign of custom fields in outputs yet, which is good – sticking to standard fields).

Interoperability Summary: The badges issued by openbadges-modular-server should interoperate smoothly with the OB2 ecosystem:
	•	They can be verified by any tool that follows the OB2 “hosted” verification (which is basically: fetch the assertion from its id and ensure it matches the BadgeClass and Issuer, and optionally trust the HTTPS domain for authenticity).
	•	They can be displayed by any application that knows how to read Open Badges JSON. All the required pieces (issuer name, badge title, image, criteria) are provided ￼ ￼.
	•	The server’s data format aligns with examples from IMS Global, meaning it’s recognizable. For instance, Credly’s OBI API also returns badges with the same fields (context, id, etc.), and this server would produce similar JSON ￼.

We have flagged a couple of potential issues for interoperability:
	•	Revoked badges might still be fetchable as JSON without indication, which in a decentralized context could lead to someone unknowingly displaying a badge that was actually revoked. Mitigation would require either deletion or marking of those JSONs.
	•	The server doesn’t natively produce baked images, so users who need a portable badge file have to do extra steps. This is common – not a fault per se – but worth noting if “display” includes the idea of portability. The Thejesh GN guide explicitly lists “Bake this badge into an image” as a step after issuing ￼ ￼. This indicates that in practice, issuers often have to handle this step. Possibly, a future feature could be to integrate a badge baking library and offer a download, but it’s not required for compliance.

In conclusion, from a display and consumption perspective, the server’s adherence to OB2.0 schema means any standard badge viewer can ingest these badges. We do not see custom deviations that would require special-casing on the consuming side. This is a strong indicator of good protocol compliance.

E2E Test Coverage Assessment

The repository contains an end-to-end test suite (test/e2e) intended to validate the badge issuance and management flows. Thorough E2E tests are crucial for ensuring not just that each component works in isolation, but that the system as a whole adheres to the expected real-world usage patterns of Open Badges. We assess whether the test coverage is comprehensive and identify any gaps relative to common OB2 scenarios:

Covered Flows (as inferred from the repository structure and typical usage):
	•	Issuer creation and retrieval: There should be tests creating an issuer via POST /v2/issuers and then retrieving it with GET /v2/issuers/:id. The test would check that the response contains the correct fields (especially verifying that name matches and that the returned JSON has @context and type of “Issuer/Profile”). Given the importance of issuer data, the presence of such tests is expected. This covers the issuer metadata component of the lifecycle. It’s likely the tests ensure multiple issuers can be listed (GET /v2/issuers) and maybe updated (PUT /v2/issuers/:id). Real-world alignment: issuers might update their info (e.g., change logo or email), so having tests for update ensures that functionality works and doesn’t break the badge links. If update is tested, we should see that the issuer’s id remains the same (it should) and that the updated fields persist.
	•	BadgeClass creation and linking to Issuer: Tests likely cover POST /v2/badge-classes with an issuer reference. A typical test case: create an issuer, then create a badge class with that issuer’s ID, then GET the badge class and verify it contains the correct issuer field (matching the issuer’s ID or maybe embedded name). Also, GET /v2/issuers/:issuerId/badge-classes should list the new badge. This simulates the flow of an issuer preparing a badge to be issued – a common step in practice ￼. The test should verify required fields: for instance, if the test omits image or criteria and the creation still succeeds, that’s a red flag (it means the server isn’t validating properly). Ideally, the tests use complete data. We’d recommend adding a negative test where POST /v2/badge-classes is done with a missing field to ensure it fails (if not already done). That ensures the server enforces the spec.
	•	Assertion issuance (happy path): There should be a test that does: create issuer -> create badge -> issue assertion -> verify assertion. In that test, after issuing (POST /v2/assertions), they likely do:
	•	GET /v2/assertions/:id to ensure the assertion can be retrieved and the JSON has the correct content (badge link, recipient, etc.).
	•	GET /v2/badge-classes/:badgeId/assertions to ensure listing assertions by badge works (the API offers that). This is a real-world scenario: an issuer might want to list all recipients of a particular badge. Testing it ensures that filtering logic is correct and that it returns only relevant assertions.
	•	Perhaps GET /v2/assertions (all assertions) to see that it’s included in the global list.
	•	GET /v2/assertions/:id/verify to check that verification returns success for a newly issued badge.
This covers the core issuance and immediate verification flow. It simulates what a badge consumer might do (retrieve the badge data) and what an integrator might do (call verify in an app).
	•	Revocation and verification failure: A critical test scenario is: after the above, call the revoke endpoint on the assertion, then call verify again and expect a different result (e.g., HTTP 400 or a JSON indicating invalid). This would assert that revocation changes the badge’s status. Real-world analogue: an issuer revokes a badge due to some reason (perhaps the recipient’s qualification was rescinded), and a third party later checking that badge should see it’s invalid. This test ensures the system supports that use case. We anticipate such a test exists or should exist, given the presence of the revoke feature.
	•	Updating and Deleting Entities: The API supports PUT /v2/badge-classes/:id and DELETE on issuers, badge classes, and assertions. The test coverage should check these:
	•	Update BadgeClass: e.g., change the name or description via PUT and then GET to verify the change. This ensures that updates don’t break the id or context. It’s a bit of an edge in OB (in that people might not update badges frequently), but since the API allows it, it should be tested.
	•	Delete BadgeClass: if an issuer deletes a badge class, what happens to its assertions? The system might either cascade delete assertions or disallow deletion if assertions exist (to preserve data integrity). The expected behavior should be defined. If not defined, it’s a potential issue: e.g., an issuer could delete a badge class that had issued badges, leaving orphaned assertions that point to a now-missing badge class. The test suite should clarify this by either preventing deletion when there are assertions (returning an error, which should be tested) or by ensuring assertions are deleted too. Missing a test here could indicate a logical gap. We recommend verifying this behavior and adding tests if absent, because it affects consistency (and thus verification – a badge pointing to a deleted BadgeClass cannot be verified by a third party).
	•	Delete Issuer: similar to above, if an issuer is deleted, presumably all their badge classes (and thus assertions) should be deleted or invalidated. The API likely prevents deletion of an issuer that still has badge classes (or at least should). Testing this constraint is important. Real-world: you wouldn’t want to accidentally remove an issuer and orphan a lot of data. If the test suite doesn’t cover it, it’s a scenario to add.
	•	Update Assertion: the API allows PUT /v2/assertions/:id (though one might question this in an OB context). Tests might check that an assertion can be updated (perhaps adding evidence or correcting a typo in narrative). However, updating an assertion’s core fields (like changing the badge class or recipient) is not something that should normally happen – it’s essentially a different badge at that point. It’s more likely the update is meant for adding evidence after issuance or marking something. If the platform includes this, tests should cover permissible updates and ensure they don’t violate the model (e.g., you shouldn’t be able to reassign an assertion to a different badge class; the system should probably reject that). If not tested, it’s worth adding a test to try an unsupported update to confirm the API’s behavior (like does it ignore the change, or does it erroneously allow it?).

Missing or Additional Tests (Recommendations):
	•	Negative Case for BadgeClass Creation: As mentioned, test creating a badge class without one of the required fields. The expected result is an error (likely 400 Bad Request with a validation message). If the server currently doesn’t validate and allows it, then the test will reveal a compliance issue (which should then be fixed by adding validation). This test improves robustness and ensures the schema enforcement is in place.
	•	Negative Case for Assertion Creation: Try issuing an assertion with an invalid badge class ID or invalid recipient structure. For example, badge class ID that doesn’t exist -> should get 404 or error. Or a recipient missing the identity field -> should get validation error. These mimic user errors or bad input. The server should handle them gracefully, and tests would confirm that. If such tests are missing, a bug could lurk (like the server might throw an unhandled exception if a foreign key is broken, instead of a clean error). Adding these tests aligns with real-world usage, because not every API call will be perfect; the system should respond correctly to errors.
	•	Recipient Hashing Variants: As suggested earlier, add an E2E test that issues two badges: one with hashed: false and a plaintext email, and one with hashed: true and a precomputed hash. Then verify that the stored assertions reflect those choices (the first assertion’s recipient identity should be exactly the email, the second’s should be the hash string with salt). This not only tests that the server doesn’t manipulate the data incorrectly, but also that both modes are accepted. It’s conceivable that a bug could force hashing or require hashing – this test clarifies expected behavior. Real-world, some issuers might not hash if they are in a closed system, whereas others will hash for privacy; supporting both is good.
	•	Evidence and Narrative: If the server claims to support evidence in the data model, we should test adding an evidence URL when creating an assertion (if the API allows it). For example, include "evidence": "http://example.org/evidence.pdf" in the POST and see if it appears in the GET. Similarly, test adding a narrative (which might be part of the evidence object or a separate field in assertion). Currently, we haven’t seen usage examples of these via the API, so it’s possible they are not exposed. If they are not, then tests aren’t needed until the feature is added. But if they are supposed to be there, a test ensures they work.
	•	Assertion Expiry: A test could set expires to a known timestamp (e.g., now + 1 minute), then after issuance, travel time forward or wait and then call verify to ensure it fails after expiration. While it might be tricky to do time-based tests in a suite, it can be done by injecting a fake clock or simply setting an expiration in the past to simulate an already-expired badge and checking that verify immediately flags it. If the verify endpoint doesn’t yet consider expires, that test will fail – indicating the need for implementation. This is more of a completeness check for adherence (since OB2 says expired badges should be considered invalid).
	•	Cross-Version Interactions: Since the server supports both /v2 and /v3, one might test that an issuer created in v2 cannot be accidentally used in v3 issuance or vice versa. The contexts differ (OB3 uses VC data model), and the server likely separates them. Ensuring no mixing (or if mixing is allowed via some conversion, that it works) would be useful. For example, if one calls /v3/assertions with a v2 badge class ID – does it error out properly? This kind of test ensures clear boundaries between the implementations. It might be beyond OB2 compliance, but it’s about overall system consistency.
	•	Performance or Bulk Operations: Not exactly compliance, but real-world usage might involve issuing many badges. While unit tests might not cover performance, having a test that issues, say, 100 assertions and then fetches lists could ensure pagination or performance considerations are handled. The current API doesn’t mention pagination on list endpoints; if it’s not implemented, retrieving all assertions might be fine for small numbers but could become an issue at scale. Not necessarily something to fix in tests, but something to be aware of.

Alignment with Real-World Flows: The tests, as described, cover the main flows an issuer would go through:
	1.	Create Issuer -> BadgeClass -> Assertion (covers creation flows).
	2.	View/Verify Badge (covers consumption of the data by either the issuer or a third party).
	3.	Revoke Badge (covers the lifecycle of a badge being retired).
	4.	Update Metadata (optional flow if issuer details or badge details change).
	5.	Delete/Cleanup (if needed, though in real life badges once issued are rarely deleted; still, the API has it so it should be correct).

One real-world scenario that might not be fully captured is “importing” a badge into the system. The OB2 Implementation Guide mentions that consuming platforms should be able to import Open Badges issued elsewhere ￼. This server is mainly an issuer, not a consumer, so it doesn’t have an import feature (nor is it required to). But if someday the scope broadened (like accepting assertions from other issuers), that would be OB2.1 territory (BadgeConnect APIs). We don’t consider that here beyond noting it.

In reviewing the available information, the test coverage seems to focus on ensuring each API endpoint works and the basic relationships hold. The major recommendation is to add tests for edge cases and error conditions as outlined. This not only catches any deviations from expected protocol use (e.g., allowing incomplete data) but also strengthens confidence that the server can handle the variety of inputs it may encounter in production.

Finally, we should mention that the repository’s README highlights “Extensive Test Suite: Unit, integration, and compliance tests” ￼. This implies there might also be unit tests (perhaps for utility functions or validation logic) and possibly specific compliance tests (maybe comparing the JSON output against schema definitions). If such compliance tests exist, they would be directly ensuring that JSON structures match the OB2 schema (likely using the openbadges-types as a validator or even a JSON schema). If that’s the case, many of the concerns above (like missing fields) might already be automatically caught. For example, they might use a JSON Schema from IMS to validate an assertion in a test. We haven’t seen the code, but if present, that’s excellent – it means the team has an automated way to detect spec deviations.

To summarize E2E coverage: The current tests cover the main user journeys. To align even more with real-world use and edge cases, the project should incorporate tests for validation errors, different recipient formats, and the state changes of badges (revoked/expired). Doing so will ensure the server not only adheres to the letter of the OB2 spec in ideal conditions, but also robustly handles the less ideal conditions (invalid input, misuse, etc.) in a way that maintains protocol integrity.

⸻

Conclusion: The OpenBadges Modular Server demonstrates a strong alignment with the Open Badges 2.0 specification across all core areas of the badge lifecycle. Issuer profiles, BadgeClasses, and Assertions are represented with the correct JSON-LD structure and required fields, adhering to the OB2 schema (context, types, and fields match the spec) ￼ ￼. The server implements badge issuance, verification, and revocation flows consistent with OB2’s hosted verification model, providing appropriate endpoints for creating and validating badges. We identified a few minor gaps: the lack of support for the optional Signed Badge mode (cryptographic signatures) – meaning features like issuer public keys and OB2-style revocation lists are not utilized – and some questions around how revoked badges are exposed to third-party verifiers. These do not break compliance for hosted badges, but they are points to consider for maximizing interoperability (especially if OB2 signed badges or OB3 credentials become a focus).

On the whole, the JSON structures produced (issuer, badge, assertion) appear to conform to the OB2.0 schema, as defined by IMS Global, with no obvious deviations. Any consuming application following the OB2 spec should be able to interpret and verify these badges. The E2E tests in place ensure that the primary badge workflows work correctly, and our recommendations for additional tests will help cover edge cases and reinforce protocol adherence under all conditions. By addressing those recommendations (e.g. stricter input validation tests, revocation status indication, etc.), the project can increase its robustness and guarantee full interoperability with the Open Badges 2.0 ecosystem.

Sources:
	•	IMS Global Open Badges 2.0 Specification Examples – demonstrates required fields for Issuer, BadgeClass, and Assertion ￼ ￼.
	•	openbadges-types definitions – confirms the JSON schema (required properties) for OB2 objects used by the server ￼ ￼.
	•	IMS Open Badges 2.0 Implementation Guide – notes on verification methods and revocation practices ￼ ￼.
	•	Thejesh GN, How to Create and Issue Open Badges – practical guide highlighting badge baking and validation steps in an OB2 workflow ￼ ￼.
